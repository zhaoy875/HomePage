# 主要内容：作为看到的好的内容笔记
----------------------------------
### 一般对象继承实现EventTarget
+ 因为EventTarget是作用于dom对象的，所以一般的构造函数或者是
原型继承都是不可用的
+ 所以实现方式就是模拟一个dom元素，然后在这个dom元素上做事件处理
``` javascript

function Class(){
  this.eventTarget = document.createElement('p');

  this.addEventListener = function(type,handle){
    this.eventTarget.addEventListener(type, handle);
  };

  this.removeEventListener = function(type,handle){
    this.eventTarget.removeEventListener(type, handle);
  };

  this.dispatchEvent = function(event){
    this.eventTarget.dispatchEvent(event);
  };
}

var o = new Class;
o.addEventListener('complete', function(e){console.log(e)});
o.dispatchEvent(new Event('complete'));
```

--------------------

### 事件流
![](http://sfault-image.b0.upaiyun.com/12/1b/121ba0d37798d6d23227d2dd49d0e58c_articlex)

### 原型链解析
![](http://sfault-image.b0.upaiyun.com/428/382/4283823667-55e0613c29a7a)

### Ajax兼容
``` javascript
function AjaxFunction(){
        var AjaxRequest;  // 缓存XHR对象便于 Ajax 使用
        try{
            // Opera 8.0+, Firefox, Safari 
            AjaxRequest = new XMLHttpRequest();
        }catch (e){

            // Internet Explorer Browsers
            try{
                AjaxRequest = new ActiveXObject("Msxml2.XMLHTTP");
            }catch (e) {
                try{
                    AjaxRequest = new ActiveXObject("Microsoft.XMLHTTP");
                }catch (e){
                    // 错误处理
                    alert("Your browser broke!");
                    return false;
                }
            }
        }
        return AjaxRequest;
    }
```
### 前端工程师系统图
![](http://sfault-image.b0.upaiyun.com/cf/51/cf518c33f1adcbbc21b917910a840b64)

### 浏览器Bower对象图
![](http://sfault-image.b0.upaiyun.com/146/503/1465036893-553e4ae9ad4c3)

### HTML5优化指南
![](http://sfault-image.b0.upaiyun.com/462/322/462322984-553e3da07b565)

### 移动端优化
![](http://sfault-image.b0.upaiyun.com/355/213/3552139123-553e3cd058c1c)

### 移动端手势操作
![](http://sfault-image.b0.upaiyun.com/457/264/457264527-553e443113302)
### js任务队列
![](http://sfault-image.b0.upaiyun.com/336/763/3367633254-55e66d3548437)
### node事件loop
![](http://sfault-image.b0.upaiyun.com/240/809/2408093305-55e66e7352df8)

### web前端技术栈
![](https://raw.githubusercontent.com/unruledboy/WebFrontEndStack/master/Web%20Front%20End%20Stack.png)
### 网络爬虫
所谓的网络“爬虫” ，就是通过一些http的request模块获取某个URL对应的页面的整个html文档，然后根据一些XPath或者CSS路径语法提取出文档的DOM节点内容，从而获取想要的数据
### 堆排序
``` c++
//  从i节点开始调整,n为节点总数 从0开始计算 i节点的子节点为 2*i+1, 2*i+2
void MinHeapFixdown(int a[], int i, int n)
{
    int j, temp;

	temp = a[i];
	j = 2 * i + 1;
	while (j < n)
	{
		if (j + 1 < n && a[j + 1] < a[j]) //在左右孩子中找最小的
			j++;

		if (a[j] >= temp)
			break;

		a[i] = a[j];     //把较小的子结点往上移动,替换它的父结点
		i = j;
		j = 2 * i + 1;
	}
	a[i] = temp;
}
//在最小堆中删除数
void MinHeapDeleteNumber(int a[], int n)
{
	Swap(a[0], a[n - 1]);
	MinHeapFixdown(a, 0, n - 1);
}
//建立最小堆
void MakeMinHeap(int a[], int n)
{
	for (int i = n / 2 - 1; i >= 0; i--)
		MinHeapFixdown(a, i, n);
}
//排序
void MinheapsortTodescendarray(int a[], int n)
{
	for (int i = n - 1; i >= 1; i--)
	{
		Swap(a[i], a[0]);
		MinHeapFixdown(a, 0, i);
	}
}
```
