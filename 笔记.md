# 主要内容：作为看到的好的内容笔记
----------------------------------
### 一般对象继承实现EventTarget
+ 因为EventTarget是作用于dom对象的，所以一般的构造函数或者是
原型继承都是不可用的
+ 所以实现方式就是模拟一个dom元素，然后在这个dom元素上做事件处理
``` javascript

function Class(){
  this.eventTarget = document.createElement('p');

  this.addEventListener = function(type,handle){
    this.eventTarget.addEventListener(type, handle);
  };

  this.removeEventListener = function(type,handle){
    this.eventTarget.removeEventListener(type, handle);
  };

  this.dispatchEvent = function(event){
    this.eventTarget.dispatchEvent(event);
  };
}

var o = new Class;
o.addEventListener('complete', function(e){console.log(e)});
o.dispatchEvent(new Event('complete'));
```

--------------------

### 事件流
![](http://sfault-image.b0.upaiyun.com/12/1b/121ba0d37798d6d23227d2dd49d0e58c_articlex)

### 原型链解析
![](http://sfault-image.b0.upaiyun.com/428/382/4283823667-55e0613c29a7a)

### Ajax兼容
``` javascript
function AjaxFunction(){
        var AjaxRequest;  // 缓存XHR对象便于 Ajax 使用
        try{
            // Opera 8.0+, Firefox, Safari 
            AjaxRequest = new XMLHttpRequest();
        }catch (e){

            // Internet Explorer Browsers
            try{
                AjaxRequest = new ActiveXObject("Msxml2.XMLHTTP");
            }catch (e) {
                try{
                    AjaxRequest = new ActiveXObject("Microsoft.XMLHTTP");
                }catch (e){
                    // 错误处理
                    alert("Your browser broke!");
                    return false;
                }
            }
        }
        return AjaxRequest;
    }
```
### 前端工程师系统图
![](http://sfault-image.b0.upaiyun.com/cf/51/cf518c33f1adcbbc21b917910a840b64)

### 浏览器Bower对象图
![](http://sfault-image.b0.upaiyun.com/146/503/1465036893-553e4ae9ad4c3)

### HTML5优化指南
![](http://sfault-image.b0.upaiyun.com/462/322/462322984-553e3da07b565)

### 移动端优化
![](http://sfault-image.b0.upaiyun.com/355/213/3552139123-553e3cd058c1c)

### 移动端手势操作
![](http://sfault-image.b0.upaiyun.com/457/264/457264527-553e443113302)
### js任务队列
![](http://sfault-image.b0.upaiyun.com/336/763/3367633254-55e66d3548437)
### node事件loop
![](http://sfault-image.b0.upaiyun.com/240/809/2408093305-55e66e7352df8)

### web前端技术栈
![](https://raw.githubusercontent.com/unruledboy/WebFrontEndStack/master/Web%20Front%20End%20Stack.png)
### 网络爬虫
所谓的网络“爬虫” ，就是通过一些http的request模块获取某个URL对应的页面的整个html文档，然后根据一些XPath或者CSS路径语法提取出文档的DOM节点内容，从而获取想要的数据
### 堆排序
``` c++
//  从i节点开始调整,n为节点总数 从0开始计算 i节点的子节点为 2*i+1, 2*i+2
void MinHeapFixdown(int a[], int i, int n)
{
    int j, temp;

	temp = a[i];
	j = 2 * i + 1;
	while (j < n)
	{
		if (j + 1 < n && a[j + 1] < a[j]) //在左右孩子中找最小的
			j++;

		if (a[j] >= temp)
			break;

		a[i] = a[j];     //把较小的子结点往上移动,替换它的父结点
		i = j;
		j = 2 * i + 1;
	}
	a[i] = temp;
}
//在最小堆中删除数
void MinHeapDeleteNumber(int a[], int n)
{
	Swap(a[0], a[n - 1]);
	MinHeapFixdown(a, 0, n - 1);
}
//建立最小堆
void MakeMinHeap(int a[], int n)
{
	for (int i = n / 2 - 1; i >= 0; i--)
		MinHeapFixdown(a, i, n);
}
//排序
void MinheapsortTodescendarray(int a[], int n)
{
	for (int i = n - 1; i >= 1; i--)
	{
		Swap(a[i], a[0]);
		MinHeapFixdown(a, 0, i);
	}
}
```

### socketIO学习笔记

+ 服务器信息传输
```javascript 
/ send to current request socket client
socket.emit('message', "this is a test");
// sending to all clients except sender
socket.broadcast.emit('message', "this is a test");
// sending to all clients in 'game' room(channel) except sender
socket.broadcast.to('game').emit('message', 'nice game');
// sending to all clients, include sender
io.sockets.emit('message', "this is a test");
// sending to all clients in 'game' room(channel), include sender
io.sockets.in('game').emit('message', 'cool game');
// sending to individual socketid
io.sockets.socket(socketid).emit('message', 'for your eyes only');
```
+ 分组数据传输
	socket.io可以使用分组方法,socket.join(),以及与之对应的socket.leave()
```javascript
io.sockets.on('connection', function (socket) {
    socket.on('firefox', function (data) {
        socket.join('firefox');
    });
    socket.on('chrome',function(data){
        socket.join('chrome');
    });
});
```
想一个分组发送数组的两种方式
```javascript
socket.broadcast.to('chrome').emit('event_name', data);
  //emit to 'room' except this socket client
io.sockets.in('chrome').emit('event_name', data)
  //emit to all socket client in the room
```
+ 一个socket是否可以同时存在于几个分组，等效于一个用户会同时在几个聊天室活跃，答案是”可以“，socket.join()添加进去就可以了。官方提供了订阅模式的示例：
```javascript
socket.on('subscribe', function(data) { 
    socket.join(data.room);
})
socket.on('unsubscribe', function(data) { 
    socket.leave(data.room);
 })
```
``` javascript
socket = io.connect('http://127.0.0.1:1338/');
socket.emit('subscribe',{"room" : "chrome"};
socket.emit('unsubscribe',{"room" : "chrome"};
```
前端触发订阅/退订事件，就可以加入对应的聊天室。 通过of方法也可以通过划分命名空间的方式，实现聊天室功能，但不如分组管理来的方便。
